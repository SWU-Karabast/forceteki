
# Implementing Cards

To implement a card, follow these steps:

### Important Note: Legacy L5R Code
This code was ported from the [Ringteki codebase](https://github.com/ringteki/ringteki) powering the online L5R client, Jigoku. During the initial implementation phase, we have included the legacy code from L5R under the folder [legacy_jigoku/](../legacy_jigoku/). These are included for reference as there is still a lot of useful code that hasn't been fully ported yet, but be careful when making changes or searching for files that you do not accidentally start doing your work in the L5R folder.

## Set up for implementation

### Find relevant info

#### Choose a card
For set 1 - 3 implementation we are maintaining a [Google Doc](https://docs.google.com/spreadsheets/d/1ewhU2NMK7_N1ZzEzswJvmyz_UOenYHWW9pXfzDttFsg/edit?usp=sharing) for tracking which cards are ready to be implemented and who is working on which card. Please check this list before choosing a card to work on. If you are just getting started, please choose a card marked "Easy" to smooth the onboarding process.

_NOTE_: Our first goal is to implement the set 1 starter decks. If possible, please prioritize cards from those decks. They are marked with the "Starter Deck" checkbox.

Note that some cards are marked as **Trivial** in the document. These cards either have no text or only have keywords, which do not require explicit implementation. We will auto-generate implementation files for all trivial cards so do not choose one of these to implement manually.

#### Find a similar implementation
If you're just getting started or working on a more complex card, it can be very useful to find another card that has similar behavior and use its implementation as a starting point. 

Since we are still building up a catalog of SWU cards, you can also look through the catalog of L5R cards to see if you can find any that use similar key words / phrases. You can search [EmeraldDB](https://www.emeralddb.org/cards) and find the matching card implementation under [legacy_jigoku/server/game/cards](../legacy_jigoku/server/game/cards). Note that the repo has changed slightly from the L5R version so some details will have changed, the dev team can help with that (or with finding relevant card impls).

### Create a card file

Cards are organized under the `/server/game/cards` directory, grouped by set. Please make sure to match the PascalCase naming format of the other cards. All card implementation files must be in TypeScript (no vanilla JavaScript files). We recommend copy-pasting from another card implementation to get started.

#### Set class name and base class
Card class names should be PascalCase and match the file name exactly.

There is a specific base class that each card type should inherit from:

| Card Type | Base Class Name |
| --- | --- |
| Unit (non-leader, non-token) | NonLeaderUnitCard |
| Event | EventCard |
| Upgrade | UpgradeCard |
| Base | BaseCard |
| ~~Leader~~ | _Still WIP_ |

Tokens require extra steps for implementation that will not be covered here.

#### Add ID data and implemented flag
Each card class should start with an override of `getImplementationId()` which returns the card's `id` and `internalName`. You can find these in the `test/json/_cardMap.json` file which is generated by the `npm run get-cards` command along with the card data files.

Copy-paste these values into the card impl file, and add a static class variable `<className>.implemented = true` to mark for the system that the card is implemented. The final result should look like below:

```javascript
import AbilityHelper from '../../AbilityHelper';
import { NonLeaderUnitCard } from '../../core/card/NonLeaderUnitCard';

export default class GroguIrresistible extends NonLeaderUnitCard {
    protected override getImplementationId() {
        return {
            id: '6536128825',
            internalName: 'grogu#irresistible'
        };
    }

    // implementation here
}

GroguIrresistible.implemented = true;
```

## Implement card abilities (quickstart)

The below is a quickstart guide on how to implement each ability type with some examples without going into too much detail on the components. See section **TODO: LINK HERE** for details on the building blocks of abilities.

All card abilities (i.e., any card text with an effect) should be defined in the `setupCardAbilities` method:

```javascript
class GroguIrresistible extends NonLeaderUnitCard {
    public override setupCardAbilities() {
        // Declare all ability types (action, triggered, constant, event, epic, replacement) here
        this.addActionAbility({
            title: 'Exhaust an enemy unit',
            cost: AbilityHelper.costs.exhaustSelf(),
            targetResolver: {
                controller: RelativePlayer.Opponent,
                immediateEffect: AbilityHelper.immediateEffects.exhaust()
            }
        });
    }
}
```

There are several ability types in SWU, each with its own initialization method. As shown above in the example of an action ability, each method accepts a property object defining the ability's behavior. Use the `AbilityHelper` import to get access to tools to help with implementations. Additionally, see [Interfaces.ts](../server/game/Interfaces.ts) for a list of available parameters for each ability type.

The ability types and methods are:

| Ability Type | Method | Definition |
| --- | --- | --- |
| Constant ability | addConstantAbility | Abilities with no bold text that have an ongoing effect |
| Action ability | addActionAbility | Abilities with bold text and a cost that provide an action the player can take |
| Triggered ability | addActionAbility | Abilities with bold text that trigger off of a game event to provide some effect |
| Event ability | setEventAbility | Any ability printed on an Event card |
| Epic action ability | setEpicActionAbility | The Epic Action ability on a Base or Leader card |
| Replacement ability | addReplacementAbility | Any ability using the term "would" or "instead" which modifies another effect (e.g. Shield, Maul) |
| Keyword ability | N/A, handled automatically | Abilities provided by keywords |

Additionally, there are specific helper methods that extend the above to make common cases simpler, such as "onAttack" triggers or upgrades that cause the attached card to gain an ability or keyword. See the relevant section below for specific details.

### Keywords

Most Keywords (sentinel, raid, smuggle, etc.) are automatically parsed from the card text. It isn't necessary to explicitly implement them unless they are provided by a conditional ability. Some examples of keywords requiring explicit implementation:

- Baze Malbus: `While you have initiative, this unit gains Sentinel.`
- Red Three: `Each other [Heroic] unit gains Raid 1.`
- Protector: `Attached unit gains Restore 2.`

### Constant abilities

Many cards provide continuous bonuses to other cards you control or detrimental effects to opponents cards in certain situations. These abilities are referred to in SWU as "constant abilities" and can be defined using the `addConstantAbility` method. Cards that enter play while the constant ability is in play will automatically have the ongoing effect applied, and cards that leave play will have the effect removed. If the card providing the effect becomes blank, the ongoing effect is automatically removed from all previously applied cards.

For a full list of properties that can be set when declaring an ongoing effect, look at [OngoingEffect.js](../server/game/core/ongoingEffect/OngoingEffect.js) _(NOTE: this is possibly stale)_. To see all the types of effect which you can use (and whether they apply to cards or players), look at [EffectLibrary.js](../server/game/ongoingEffects/OngoingEffectLibrary.ts). Here are some common scenarios:

#### Matching conditions vs matching specific cards

The ongoing effect declaration (for card effects, not player effects) takes a `matchTarget` property. In most cases this will be a function that takes a `Card` object and should return `true` if the ongoing effect should be applied to that card.

```javascript
// Each Rebel unit you control gains +1/+1
this.constantAbility({
    matchTarget: card => card.hasSomeTrait(Trait.Rebel),
    ongoingEffect: AbilityHelper.ongoingEffects.modifyStats({ power: 1, hp: 1 }),
});
```

In some cases, an ongoing effect should be applied to a specific card. While you could write a `matchTarget` function to match only that card, you can provide the `Card` or `Player` object as a shorthand.

```javascript
// This player's leader unit gets Sentinel while it is deployed (i.e., in the arena)
this.constantAbility({
    matchTarget: this.controller.leader,
    targetLocationFilter: WildcardLocation.AnyArena,
    ongoingEffect: AbilityHelper.ongoingEffects.gainKeyword(KeywordName.Sentinel),
});
```

If not provided, `matchTarget` will default to targeting only the card that owns the constant ability.

#### Conditional ongoing effects

Some ongoing effects have a 'when', 'while' or 'if' clause within their text. These cards can be implemented by passing a `condition` function into the constant ability declaration. The ongoing effect will only be applied when the function returns `true`. If the function returns `false` later on, the ongoing effect will be automatically unapplied from the cards it matched.

```javascript
// While this unit is exhausted, it gains +1/+1
this.constantAbility({
    condition: () => this.exhausted,
    ongoingEffect: AbilityHelper.ongoingEffects.modifyStats({ power: 1, hp: 1 })
});
```

#### Filtering by card type, owner, location
Note also that, similar to ability targets described below, there are shorthand filters for the card properties location, owner, and card type. See the relevant section below for details. **TODO THIS PR: add section link**


All of these filters are available for filtering target cards (e.g., `targetLocationFilter`), but for checking the properties of the source card (the card that owns the ability) only `sourceLocationFilter` is available:

```javascript
// While this card is in the ground arena, all of the opponent's units in the space arena get -1/-1
this.constantAbility({
    sourceLocationFilter: Location.GroundArena,
    targetLocationFilter: Location.SpaceArena,
    targetCardType: WildcardCardType.Unit,
    targetController: RelativePlayer.Opponent,
    ongoingEffect: AbilityHelper.ongoingEffects.modifyStats({ power: -1, hp: -1 })
});
```

#### Applying multiple effects at once
As a shorthand, it is possible to pass an array into the `ongoingEffect` property to apply multiple effects that have the same conditions / matching functions.

```javascript
// This unit gets Sentinel and +1/+1 while damaged
this.constantAbility({
    condition: () => this.damage !== 0,
    effect: [
        AbilityHelper.ongoingEffects.gainKeyword(KeywordName.Sentinel),
        AbilityHelper.ongoingEffects.modifyStats({ power: -1, hp: -1 })
    ]
});
```

#### **IGNORE THIS SECTION, STILL WIP**: Applying effects to cards which aren't in play

By default, ongoing effects will only be applied to cards in the play area.  Certain cards effects refer to cards in your hand, such as reducing their cost. In these cases, set the `targetLocation` property to `'hand'`.

```javascript
// Each Direwolf card in your hand gains ambush (X). X is that card's printed cost.
this.constantAbility({
    // Explicitly target the effect to cards in hand.
    targetLocationFilter: 'hand',
    match: card => card.hasTrait('Direwolf'),
    effect: AbilityHelper.effects.modifyCost()
});
```

This also applies to provinces, holdings and strongholds, which the game considers to be 'in play' even though they aren't in the play area.  Where an effect needs to be applied to these cards (or to characters who are in a province), set `targetLocation` to `'province'`.

```javascript
// This province gets +5 strength during [political] conflicts.
this.constantAbility({
    match: this,
    targetLocation: 'province',
    condition: () => this.game.isDuringConflict('political'),
    effect: AbilityHelper.effects.modifyProvinceStrength(5)
});
```

#### **IGNORE THIS SECTION, STILL WIP**: Player modifying effects



Certain cards provide bonuses or restrictions on the player itself instead of on any specific cards. These effects are marked as `Player` effects in `/server/game/effects.js`. For player effects, `targetController` indicates which players the effect should be applied to (with `'current'` acting as the default). Player effects should not have a `match` property.

```javascript
// While this character is participating in a conflict, opponents cannot play events.
this.constantAbility({
    condition: () => this.isParticipating(),
    targetController: 'opponent',
    effect: AbilityHelper.effects.playerCannot(context => context.source.type === 'event')
});
```

#### Upgrade helper methods
Some helper methods are available to make it easier to declare constant abilities on upgrades, since these are extremely common.

##### Static stat bonuses from upgrades

Static upgrade stat bonuses from the printed upgrade values are automatically included in combat calculations for the attached unit.

##### Effects targeting attached card

Since most upgrade abilities target the attached card, we have helper methods available to declare such abilities succintly.

Most upgrades say that the attached unit gains a triggered ability:
```javascript
// Attached character gains ability 'On Attack: Exhaust the defender'
this.addGainTriggeredAbilityTargetingAttached({
    title: 'Exhaust the defender on attack',
    // note here that context.source refers to the attached unit card, not the upgrade itself
    when: { onAttackDeclared: (event, context) => event.attack.attacker === context.source },
    targetResolver: {
        cardCondition: (card, context) => card === context.event.attack.target,
        immediateEffect: AbilityHelper.immediateEffects.exhaust()
    }
});
```

It is also common for an upgrade to grant a keyword to the attached:
```javascript
// Attached character gains keyword 'Restore 2'
this.addGainKeywordTargetingAttached({
    keyword: KeywordName.Restore,
    amount: 2
});
```

In some rare cases an upgrade's ability targets the attached card without giving it any new abilities
```javascript
// Entrenched ability
this.addConstantAbilityTargetingAttached({
    title: 'Attached unit cannot attack bases',
    ongoingEffect: AbilityHelper.ongoingEffects.cannotAttackBase(),
});
```

### Action abilities

Action abilities are abilities from card text which provide actions that players may trigger during the action phase. They are declared using the `addActionAbility` method. See [ActionAbility.ts](../server/game/core/ability/ActionAbility.ts) for full documentation (_NOTE: may be stale_). Here are some common scenarios:

#### Declaring an action

When declaring an action, use the `addActionAbility` method and provide it with a `title` property. The title is what will be displayed in the menu players see when clicking on the card.

```javascript
export default class GroguIrresistible extends NonLeaderUnitCard {
    public override setupCardAbilities() {
        this.addActionAbility({
            title: 'Exhaust an enemy unit',
            cost: AbilityHelper.costs.exhaustSelf(),
            targetResolver: {
                controller: RelativePlayer.Opponent,
                immediateEffect: AbilityHelper.immediateEffects.exhaust()
            }
        });
    }
}
```

#### Checking ability restrictions

Card abilities can only be triggered if they have the potential to modify game state (outside of paying costs). To ensure that the action's play restrictions are met, pass a `condition` function that returns `true` when the restrictions are met, and `false` otherwise. If the condition returns `false`, the action will not be executed and costs will not be paid.

```javascript
// During a conflict, give this character +2/+2
this.action({
    title: 'Give this character +2/+2',
    condition: () => this.game.isDuringConflict(),
    // ...
});
```

```javascript
// While this character is participating in a conflict....
this.action({
    title: 'Switch a character\'s M and P skill',
    condition: context => context.source.isParticipating(),
    // ...
});
```

#### Paying additional costs for action

Some actions have an additional cost, such as bowing the card. In these cases, specify the `cost` parameter. The action will check if the cost can be paid. If it can't, the action will not execute. If it can, costs will be paid automatically and then the action will execute.

For a full list of costs, look at `/server/game/costs.js`.

```javascript
// During a conflict, bow this character. Choose another [crane] character - that character gets +0/+3 until the end of the conflict
this.action({
    title: 'Give a character +0/+3',
    // This card must be bowed as a cost for the action.
    cost: AbilityHelper.costs.bowSelf(),
    // ...
});
```

If a card has multiple costs, an array of cost objects may be sent using the `cost` property.

```javascript
this.action({
    title: 'Give all non-unique participating characters -2/-0',
    // This card must be bowed AND sacrificed as a cost for the action.
    cost: [
        AbilityHelper.costs.bowSelf(),
        AbilityHelper.costs.sacrificeSelf()
    ],
    // ...
});
```

### Triggered abilities

Triggered abilities include all card abilities that have **Interrupt**, **Forced Interrupt**, **Reaction**, **Forced Reaction**. Implementing a triggered ability is similar to actions above, but instead of calling `this.action`, `this.reaction` or `this.interrupt` are used instead. Costs and targets are declared in the same way. For full documentation of properties, see `/server/game/triggeredability.js`. Here are some common scenarios:

#### Defining the triggering condition

Each triggered ability has an associated triggering condition. This is done using the `when` property. This should be an object whose sub-property is the name of the event, and whose value is a function which takes the event and the context object. When the function returns `true`, the ability will be executed.

```javascript
this.reaction({
    // When this card enters play, honor it
    when: {
    	onCharacterEntersPlay: (event, context) => event.card === context.source
    },
    gameAction: AbilityHelper.actions.honor()
});
```

In rare cases, there may be multiple triggering conditions for the same ability. For example, [Ikoma Prodigy](https://fiveringsdb.com/card/ikoma-prodigy) gains an honor when fate is placed on her while playing her, or while she is in play. In these cases, just define an additional event on the `when` object.

```javascript
this.reaction({
    title: 'Gain 1 honor',
    when: {
        onCharacterEntersPlay: (event, context) => event.card === context.source && context.source.fate > 0,
        onMoveFate: (event, context) => event.recipient === context.source && event.fate > 0
    },
    gameAction: AbilityHelper.actions.gainHonor()
});
```

#### Forced reactions and interrupts

Forced reactions and interrupts do not provide the player with a choice - unless cancelled, the effect will always resolve.

To declare a forced reaction, use the `forcedReaction` method:

```javascript
this.forcedReaction({
    title: 'Can\'t be discarded or remove fate',
    when: {
        onPhaseStarted: (event, context) => event.phase === 'fate' && context.player.opponent && 
                                            context.player.honor >= context.player.opponent.honor + 5
    },
    effect: 'stop him being discarded or losing fate in this phase',
    gameAction: AbilityHelper.actions.cardLastingEffect({
        duration: 'untilEndOfPhase',    
        effect: [
            AbilityHelper.effects.cardCannot('removeFate'),
            AbilityHelper.effects.cardCannot('discardFromPlay')
        ]
    })
});
```

To declare a forced interrupt, use the `forcedInterrupt` method.

```javascript
this.forcedInterrupt({
    when: {
        onCardLeavesPlay: (event, context) => event.card === context.source && context.source.hasSincerity()
    },
    /// ...
    effect: '{1} draws a card due to {0}\'s Sincerity',
    effectArgs: context => context.player,
    gameAction: AbilityHelper.actions.draw()
});
```

#### 'Would' interrupts

Some abilities allow the player to cancel an effect. These effects are always interrupts, and are usually templated as 'Interrupt: When [trigger] would....'.  These are implemented
using the `wouldInterrupt` method.  The context object for triggered ability has a useful `cancel` method which can be called in these cases

```javascript
this.wouldInterrupt({
    title: 'Cancel an event',
    when: {
        onInitiateAbilityEffects: event => event.card.type === 'event'
    },
    cost: AbilityHelper.costs.dishonor(card => card.hasTrait('courtier')),
    effect: 'cancel {1}',
    effectArgs: context => context.event.card,
    handler: context => context.cancel()
});
```

#### Abilities outside of play

Certain abilities, such as that of Vengeful Oathkeeper can only be activated in non-play locations. Such reactions should be defined by specifying the `location` property with the location from which the ability may be activated. The player can then activate the ability when prompted.

```javascript
this.reaction({
	when: {
		afterConflict: (event, context) => context.conflict.loser === context.player && context.conflict.conflictType === 'military'
	},
    location: 'hand',
    gameAction: AbilityHelper.actions.putIntoPlay()
})
```

## Ability building blocks

#### Context object

When the game starts to resolve an ability, it creates a context object for that ability. Generally, the context ability has the following structure:

```javascript
class AbilityContext {
    constructor(properties) {
        this.game = properties.game;
        this.source = properties.source;
        this.player = properties.player;
        this.ability = properties.ability;
        this.costs = {};
        this.targets = {};
        this.rings = {};
        this.selects = {};
        this.stage = Stages.Effect;
    }
}
```

`context.source` is the card with the ability being used, and `context.player` is the player who is using the ability (almost always the controller of the `context.source`). When implementing actions and other triggered abilities, `context` should almost always be used (instead of `this`) to reference cards or players.  The only exception is that `this.game` can be used as an alternative to `context.game`.

#### `context.source` and upgrades

Note that in the case of upgrade abilities that give an ability to the attached card, `context.source` has to be used slightly differently than normal:
```javascript
// Attached character gains ability 'On Attack: Exhaust the defender'
this.addGainTriggeredAbilityTargetingAttached({
    title: 'Exhaust the defender on attack',
    // note here that context.source refers to the attached unit card, not the upgrade itself
    when: { onAttackDeclared: (event, context) => event.attack.attacker === context.source },
    targetResolver: {
        cardCondition: (card, context) => card === context.event.attack.target,
        immediateEffect: AbilityHelper.immediateEffects.exhaust()
    }
});
```
Whereas in most cases `context.source` refers to `this` (i.e., the source card of the ability), since in this case the ability is being triggered on the attached unit card, `context.source` refers to the unit that the upgrade is attached to. The above `when` condition is equivalent to:

`when: { onAttackDeclared: (event, context) => event.attack.attacker === this.parentCard }`

### Using GameSystems for building ability effects

In general, the effects of an ability should be implemented using game systems represented by the GameSystem class, which is turn wrapped by helper methods under the AbilityHelper import.

#### Game Systems

All ability types rely on GameSystems for making changes to game state.  Available game systems can be found in [GameSystemLibrary.ts](server\game\gameSystems\GameSystemLibrary.ts), along with any parameters and their defaults.  Game systems as properties in the main ability section default to targeting the card generating the ability (for cards) or the opponent (for players). 

Game systems included in `targetResolver` (or in one of `targetResolvers`) will default to the target chosen by the `targetResolver`'s resolution (see **TODO INCLUDE TARGET RESOLVERS SECTION LINK** for details). You can change the target of a game system or the parameters by passing either an object with the properties you want, or a function which takes `context` and returns those properties.

```javascript
// Action: During a conflict, bow this attachment – move attached character to the conflict.
this.action({
    title: 'Move this character into the conflict',
    cost: AbilityHelper.costs.bowSelf(),
    gameAction: AbilityHelper.actions.moveToConflict(context => ({ target: context.source.parent }))
});
```

```javascript
// Reaction: After this character enters play – place 1 fate from an opponent's fate pool on it.
this.reaction({
    title: 'Steal a fate',
    // reaction condition code
    gameAction: AbilityHelper.actions.placeFate(context => ({ origin: context.player.opponent }))
});
```

#### Effect messages

Once costs have been paid and targets chosen (but before the ability resolves), the game automatically displays a message in the chat box which tells both players the ability, costs and targets of the effect.  Game actions will automatically generate their own effect message, although this will only work for a single game action.  If the effects of the ability involve two or more game actions, or the effect is a lasting effect or uses a handler, then an `effect` property is required.  The effect property will be passed the target (card(s) or ring) of the effect (or the source if there are no targets) as its first parameter (and so can be referenced using `'{0}'` in the effect property string).  If other references are required, this can be done using curly bracket references in the effect string(`'{1}', '{2', etc`) and supplying an `effectArgs` property (which generally will be a function taking the `context` object):

```javascript
this.action({
    // Action: Return this attachment to your hand and dishonor attached character.
    title: 'Return court mask to hand',
    effect: 'return {0} to hand, dishonoring {1}',
    effectArgs: context => context.source.parent,
    gameAction: [AbilityHelper.actions.returnToHand(), AbilityHelper.actions.dishonor(context => ({ target: context.source.parent }))]
});
```

```javascript
this.action({
    // Action: While this character is participating in a conflict, choose another participating character – until the end of the conflict, that character gets +2/+2 for each holding you control.
    title: 'Give a character a bonus for each holding',
    condition: context => context.source.isParticipating(),
    target: {
        cardType: 'character',
        cardCondition: (card, context) => card.isParticipating() && card !== context.source,
        gameAction: AbilityHelper.actions.cardLastingEffect(context => ({
            effect: AbilityHelper.effects.modifyBothSkills(2 * context.player.getNumberOfHoldingsInPlay())
        }))
    },
    effect: 'give {0} +{1}{2}/+{1}{3}',
    effectArgs: context => [2 * context.player.getNumberOfHoldingsInPlay(), 'military', 'political']
});
```

#### Lasting effects

Unlike constant abilities, lasting effects are typically applied during an action, reaction or interrupt and expire after a specified period of time.  Lasting effect use the same properties as constant abilities, above.  Lasting effects are applied using the `cardLastingEffect`, `ringLastingEffect` or `playerLastingEffect`, depending on what they affect.  They take a `duration:` property which is one of `untilEndOfConflict` (default), `untilEndOfPhase` or `untilEndOfRound`.

```javascript
// Action: During a conflict, bow this character. Choose another [crane] character – that character 
// gets +3 [political] until the end of the conflict.
this.action({
    title: 'Give a character +0/+3',
    condition: () => this.game.isDuringConflict(),
    cost: AbilityHelper.costs.bowSelf(),
    target: {
        cardType: 'character',
        cardCondition: (card, context) => card !== context.source && card.isFaction('crane'),
        gameAction: AbilityHelper.actions.cardLastingEffect(() => ({
            duration: 'untilEndOfConflict',
            effect: AbilityHelper.effects.modifyPoliticalSkill(3)
        }))
    },
    effect: 'give {0} +3{1} skill',
    effectArgs: () => 'political'
});

```

To apply an effect to last until the end of the current phase, use `untilEndOfPhase`:
```javascript
// Action: Reduce the cost of the next event you play this phase by 1.
this.action({
    title: 'Reduce cost of next event by 1',
    effect: 'reduce the cost of their next event by 1',
    gameAction: AbilityHelper.actions.playerLastingEffect({
        duration: 'untilEndOfPhase',
        effect: AbilityHelper.effects.reduceNextPlayedCardCost(1, card => card.type === 'event')
    })
});
```

To apply an effect to last until the end of the round, use `untilEndOfRound`:
```javascript
/// Action: Choose a holding you control – you may trigger each of that holding's triggered abilities an additional time this round (or specified period).
this.action({
    title: 'Add an additional ability use to a holding',
    target: {
        cardType: 'holding',
        location: 'province',
        controller: 'self',
        gameAction: AbilityHelper.actions.cardLastingEffect({
            duration: 'untilEndOfPhase',
            targetLocation: 'province',
            effect: AbilityHelper.effects.increaseLimitOnAbilities()
        })
    },
    effect: 'add an additional use to each of {0}\'s abilities'
});
```

#### Limiting an action to a specific phase

Some actions are limited to a specific phase by their card text. You can pass an optional `phase` property to the action to limit it to just that phase. Valid phases include `'dynasty'`, `'draw'`, `'conflict'`, `'fate'`. The default is `'any'` which allows the action to be triggered in any phase.

```javascript
this.action({
    title: 'Sacrifice to discard an attachment',
    cost: AbilityHelper.costs.sacrificeSelf(),
    phase: 'conflict',
    target: {
        cardType: 'attachment',
        gameAction: AbilityHelper.actions.discardFromPlay()
    }
});
```

#### Limiting the number of uses

Some actions have text limiting the number of times they may be used in a given period. You can pass an optional `limit` property using one of the duration-specific ability limiters. See `/server/game/abilitylimit.js` for more details.

```javascript
this.action({
    title: 'Remove 1 fate',
    limit: AbilityHelper.limit.perConflict(2),
    // ...
});
```

#### Actions outside of play

Certain actions, such as that of Ancestral Guidance, can only be activated while the character is in the discard pile. Such actions should be defined by specifying the `location` property with the location from which the ability may be activated. The player can then activate the ability by simply clicking the card. If there is a conflict (e.g. both the ability and playing the card normally can occur), then the player will be prompted.

```javascript
this.action({
    title: 'Play from discard pile',
    location: 'conflict discard pile',
    // ...
})
```

### Target resolvers

Most ability types (other than constant, keyword, and replacement abilities) can specify to 'choose' or otherwise target a specific card. This should be implemented using a "target resolver," which defines a set of criteria that will be use to select the set of target cards to allow the player to choose between. Target resolvers are provided using `targetResolver` property. 

The `targetResolver` property should include any limitations set by the ability, using the `cardTypeFilter`, `locationFilter`, `controller` and/or `cardCondition` property. A game system can also be included by using the `immediateEffect` property, which will restrict the card chosen to those for which that game system is legal (e.g. only units in an arena and base can be damaged, only upgrades can be unattached, etc.).  If an array of game systems is specified, then the target only needs to meet the requirements of one of them.

Generally, it's a good idea to pass at least a `cardTypeFilter` property, as that will automatically change the prompt to make it easier for the player to understand what is going on. Most other properties that apply to `Game.promptForSelect` are also valid here.

```javascript
this.action({
    title: 'Grant Covert to a character',
    target: {
        cardType: 'character',
        location: 'play area'
    },
    // ...
});
```

```javascript
this.action({
    title: 'Sacrifice to discard an attachment'
    target: {
        cardType: 'attachment',
        gameAction: AbilityHelper.actions.discardFromPlay()
    },
    // ...
});
```

#### Multiple targets

Some card abilities require multiple targets. These may be specified using the `targets` property. Each sub key under `targets` is the name that will be given to the chosen card, and the value is the prompt properties.

```javascript
// Action: While this character is participating in a conflict, choose a ready non-participating character with printed 
// cost 2 or lower controller by each player – move each chosen character to the conflict
this.action({
    title: 'Move characters into conflict',
    condition: context => context.source.isParticipating(),
    targets: {
        myChar: {
            cardType: 'character',
            controller: 'self',
            cardCondition: card => !card.bowed && card.getCost() <= 2,
            gameAction: AbilityHelper.actions.moveToConflict()
        },
        oppChar: {
            cardType: 'character',
            controller: 'opponent',
            cardCondition: card => !card.bowed && card.getCost() <= 2,
            gameAction: AbilityHelper.actions.moveToConflict()                    
        }
    }
});
```

Once all targets are chosen, they will be set using their specified name under the `targets` property on the handler context object.

#### Select options

Some abilities require the player (or their opponent) to choose between multiple options.  This is done in the same way as targets above, but by using the `mode` property set to `'select'`.  In addition, a `choices` object should be included, which contains key:value pairs where the key is the option to display to the player, and the value is either a function which takes the `context` object and returns a boolean indicating whether this option is legal, or a game action which will be evaluated on the basis of the specified target (or default as detailed below) to determine whether the choice is legal.  The selected option is stored in `context.select.choice` (or `context.selects[targetName].choice` for an ability with multiple targets).

```javascript
// Action: During a conflict at this province, select one – switch the contested ring with an unclaimed 
// ring, or switch the conflict type.
this.action({
    title: 'Switch the conflict type or ring',
    condition: context => context.source.isConflictProvince(),
    target: {
        player: 'self',
        mode: 'select',
        choices: {
            'Switch the contested ring': () => _.any(this.game.rings, ring => ring.isUnclaimed()),
            'Switch the conflict type': () => true
        }
    },
    // ...
});
```

```javascript
// Action: If an opponent has declared 2 or more conflicts against you this phase, select one – 
// take 1 fate or 1 honor from that opponent.
this.action({
    title: 'Take 1 fate or 1 honor',
    phase: 'conflict',
    condition: context => this.game.getConflicts(context.player.opponent).filter(conflict => !conflict.passed).length > 1,
    target: {
        player: 'self',
        mode: 'select',
        choices: {
            'Take 1 fate': AbilityHelper.actions.takeFate(),
            'Take 1 honor': AbilityHelper.actions.takeHonor()
        }
    }
});
```

### Ability limits

Actions, reactions, and interrupts can have limits on how many times they may be used within a certain period. These limits can be set by setting the `limit` property on the ability. The `ability` object has a limit helper with methods for the different periods.

To limit an ability per conflict, use `AbilityHelper.limit.perConflict(x)`.

To limit an ability per phase, use `AbilityHelper.limit.perPhase(x)`.

To limit an ability per round, use `AbilityHelper.limit.perRound(x)`.

In each case, `x` should be the number of times the ability is allowed to be used.

### Language

#### Game messages should begin with the player doing the action

Game messages should begin with the name of the player to ensure a uniform format and make it easy to see who triggered an ability.

* **Bad**: Kaiu Shuichi triggers to gain 1 fate for Player1
* **Good**: Player1 uses Kaiu Shuichi to gain 1 fate

#### Game messages should not end in punctuation

No game messages should end in a period, exclaimation point or question mark.

* **Bad**: Player1 draws 2 cards.
* **Good**: Player1 draws 2 cards

#### Game messages should use present tense.

All game messages should use present tense.

* **Bad**: Player1 has used Isawa Masahiro to discard Miya Mystic
* **Bad**: Player1 chose to discard Miya Mystic
* **Good**: Player1 uses Isawa Masahiro to discard Miya Mystic
* **Good**: Player1 chooses to discard Miya Mystic

#### Targeting prompts should use the format "Choose a \<card type\>" where possible.

Targeting prompts should ask the player to choose a card or a card of particular type to keep prompt titles relatively short, without specifying the final goal of card selection.

* **Bad**: Choose a character to return to hand
* **Good**: Choose a character

**Exception:** If a card requires the player to choose multiple cards (e.g. Rebuild), or if a card requires the player's opponent to choose a card (e.g. Endless Plains) you can add context about which one they should be selecting. Just keep it as short as reasonably possible.

As valid selections are already presented to the user via visual clues, targeting prompts should not repeat selection rules in excessive details. Specifying nothing more and nothing less than the eligible card type (if any) is the good middle ground (this is what most prompts will default to).

* **Bad**: Choose a Bushi
* **Good**: Choose a character

* **Bad**: Choose a defending Crab character
* **Good**: Choose a character

* **Bad**: Choose a card from your discard pile
* **Good**: Choose a card

* **Good**: Choose an attachment or location
