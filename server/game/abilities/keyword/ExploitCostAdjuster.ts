import type { AbilityContext } from '../../core/ability/AbilityContext';
import { CardTargetResolver } from '../../core/ability/abilityTargets/CardTargetResolver';
import type { Card } from '../../core/card/Card';
import type { CardWithCost } from '../../core/card/CardTypes';
import type { Aspect, PlayType } from '../../core/Constants';
import { EventName, RelativePlayer, TargetMode, WildcardCardType } from '../../core/Constants';
import { CostAdjuster, CostAdjustType } from '../../core/cost/CostAdjuster';
import type { ICostResult } from '../../core/cost/ICost';
import { GameEvent } from '../../core/event/GameEvent';
import type Game from '../../core/Game';
import * as Contract from '../../core/utils/Contract';
import type { PlayCardResourceCost } from '../../costs/PlayCardResourceCost';
import type { IDefeatCardProperties } from '../../gameSystems/DefeatCardSystem';
import { DefeatCardSystem } from '../../gameSystems/DefeatCardSystem';
import { DefeatSourceType } from '../../IDamageOrDefeatSource';

export class ExploitCostAdjuster extends CostAdjuster {
    private readonly defeatSystem: DefeatCardSystem;
    private readonly exploitKeywordAmount: number;
    private readonly targetResolver: CardTargetResolver;

    private disableSelf = false;
    private minimumExploitCount?: number = null;
    private numExploitedCards?: number = null;

    public constructor(game: Game, card: CardWithCost, exploitKeywordAmount: number) {
        super(game, card,
            {
                costAdjustType: CostAdjustType.Decrease,

                // if we haven't yet resolved the exploit targets, just return the maximum possible discount amount
                amount: (_card, _player, context) =>
                    (this.numExploitedCards ? this.numExploitedCards * 2 : this.getMaxExploitCount(context) * 2),
            }
        );

        this.exploitKeywordAmount = exploitKeywordAmount;

        const defeatProps: IDefeatCardProperties = { defeatSource: DefeatSourceType.Ability };
        this.defeatSystem = new DefeatCardSystem(defeatProps);

        this.targetResolver = new CardTargetResolver(
            'exploit', {
                mode: TargetMode.BetweenVariable,
                minNumCardsFunc: () => this.minimumExploitCount ?? 1,
                maxNumCardsFunc: (context) => this.getMaxExploitCount(context),
                cardTypeFilter: WildcardCardType.Unit,
                immediateEffect: this.defeatSystem,
                controller: RelativePlayer.Self,
                appendToDefaultTitle: 'to exploit',
            }
        );
    }

    public override isExploit(): this is ExploitCostAdjuster {
        return true;
    }

    public override canAdjust(playingType: PlayType, card: Card, context: AbilityContext, attachTarget?: Card, ignoredAspects?: Aspect) {
        if (this.disableSelf) {
            return false;
        }

        // if we haven't already triggered the Exploit selection, check available legal targets
        if (this.numExploitedCards == null && !this.targetResolver.hasLegalTarget(context)) {
            return false;
        }

        return super.canAdjust(playingType, card, context, attachTarget, ignoredAspects);
    }

    public override queueGenerateEventGameSteps(events: any[], context: AbilityContext, resourceCost: PlayCardResourceCost, result?: ICostResult) {
        Contract.assertIsNullLike(this.minimumExploitCount);
        Contract.assertIsNullLike(this.numExploitedCards);

        // briefly remove ourself from the cost adjustment calculation so we can determine how much we are required to Exploit
        this.disableSelf = true;
        const preAdjustedCost = resourceCost.getAdjustedCost(context);
        this.disableSelf = false;

        this.minimumExploitCount = Math.max(1, Math.ceil((preAdjustedCost - context.player.readyResourceCount) / 2));

        if (this.getMaxExploitCount(context) < this.minimumExploitCount) {
            result.cancelled = true;
            return;
        }

        // step 1: ask player to choose defeat targets
        this.targetResolver.resolve(context, result);

        // step 2: generate the Exploit event (which in turn emits the defeat events)
        context.game.queueSimpleStep(() => {
            if (!result.cancelled) {
                this.numExploitedCards = context.targets.exploit.length;
                events.push(this.buildExploitEvent(context));
            }
        }, `generate exploit event for ${context.source.internalName}`);
    }

    private buildExploitEvent(context) {
        Contract.assertNotNullLike(context.targets.exploit);
        Contract.assertIsNullLike(context.costs.exploitedUnitsInformation);

        const payEvents = [];
        context.costs.exploitedUnitsInformation = [];

        // create the events for defeating the exploited units
        for (const exploitUnit of context.targets.exploit) {
            payEvents.push(this.defeatSystem.generateRetargetedEvent(exploitUnit, context));
        }

        // create an event for the Exploit operation itself, which will cache the "last known information"
        // of the exploited units in case it needs to be referred to by abilities
        const exploitEvent = new GameEvent(
            EventName.onExploitUnits,
            context,
            { units: context.targets.exploit },
            (_event) => {
                for (const exploitEvent of payEvents) {
                    Contract.assertTrue(exploitEvent.isResolvedOrReplacementResolved);

                    context.costs.exploitedUnitsInformation.push(exploitEvent.lastKnownInformation);
                }
            }
        );

        // the Exploit event will emit the defeat events as contingent events and resolve them in earlier order
        exploitEvent.setContingentEventsGenerator((event) => {
            for (const payEvent of payEvents) {
                payEvent.order = event.order - 1;
            }
            return [...payEvents];
        });

        return exploitEvent;
    }

    private getMaxExploitCount(context: AbilityContext) {
        return Math.min(this.exploitKeywordAmount, this.targetResolver.getAllLegalTargets(context).length);
    }
}
