import { AbilityContext } from '../../core/ability/AbilityContext';
import { CardTargetResolver } from '../../core/ability/abilityTargets/CardTargetResolver';
import { Card } from '../../core/card/Card';
import { UnitCard } from '../../core/card/CardTypes';
import { EventName, MetaEventName, PlayType, RelativePlayer, TargetMode, WildcardCardType } from '../../core/Constants';
import { Result } from '../../core/cost/ICost';
import { GameEvent } from '../../core/event/GameEvent';
import * as Contract from '../../core/utils/Contract';
import { PlayCardResourceCost } from '../../costs/PlayCardResourceCost';
import { DefeatCardSystem, IDefeatCardProperties } from '../../gameSystems/DefeatCardSystem';
import { DefeatSourceType } from '../../IDamageOrDefeatSource';

export class ExploitPlayCardResourceCost extends PlayCardResourceCost {
    private readonly defeatSystem: DefeatCardSystem;
    private readonly exploitKeywordAmount: number;
    private readonly targetResolver: CardTargetResolver;

    private minimumExploitCount?: number = null;

    public constructor(exploitKeywordAmount: number, playType: PlayType) {
        super(playType);

        this.exploitKeywordAmount = exploitKeywordAmount;

        const defeatProps: IDefeatCardProperties = { defeatSource: DefeatSourceType.Ability };
        this.defeatSystem = new DefeatCardSystem(defeatProps);

        // const exploitResolverProperties: ICardTargetResolver<AbilityContext> = ;
        this.targetResolver = new CardTargetResolver(
            'exploit', {
                mode: TargetMode.BetweenVariable,
                minNumCardsFunc: () => this.minimumExploitCount ?? 1,
                maxNumCardsFunc: (context) => this.getMaxExploitCount(context),
                cardTypeFilter: WildcardCardType.Unit,
                immediateEffect: this.defeatSystem,
                controller: RelativePlayer.Self,
                appendToDefaultTitle: 'to exploit',
            }
        );
    }

    public override usesExploit(): this is ExploitPlayCardResourceCost {
        return true;
    }

    // TODO THIS PR: should we always prompt for Exploit, even if it's the only play option?
    public override resolve(context: AbilityContext<Card>, result: Result) {
        const adjustedCost = super.getAdjustedCost(context);

        this.minimumExploitCount = Math.max(1, Math.ceil((adjustedCost - context.player.readyResourceCount) / 2));

        if (this.getMaxExploitCount(context) < this.minimumExploitCount) {
            result.cancelled = true;
            return;
        }

        this.targetResolver.resolve(context, result);
    }

    public override payEvents(context) {
        Contract.assertNotNullLike(context.targets.exploit);
        Contract.assertIsNullLike(context.costs.exploitedUnits);

        const payEvents = [];
        context.costs.exploitedUnits = [];

        for (const exploitUnit of context.targets.exploit) {
            payEvents.push(this.defeatSystem.generateRetargetedEvent(exploitUnit, context));
            context.costs.exploitedUnits.push(exploitUnit);
        }

        const exploitEvent = new GameEvent(
            EventName.onExploitUnits,
            context,
            { units: context.targets.exploit }
        );
        exploitEvent.setContingentEventsGenerator((_event) => payEvents);

        const remainingCost = super.getAdjustedCost(context) - (context.costs.exploitedUnits.length * 2);
        Contract.assertNonNegative(remainingCost);

        return [exploitEvent, this.getExhaustResourceEvent(context, remainingCost)];
    }

    protected override getAdjustedCost(context: AbilityContext<Card>) {
        return Math.max(0, super.getAdjustedCost(context) - (this.getMaxExploitCount(context) * 2));
    }

    private getMaxExploitCount(context: AbilityContext) {
        return Math.min(this.exploitKeywordAmount, this.targetResolver.getAllLegalTargets(context).length);
    }
}
