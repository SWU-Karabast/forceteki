import { CardTargetResolver } from '../../core/ability/abilityTargets/CardTargetResolver';
import { UnitCard } from '../../core/card/CardTypes';
import BaseCardSelector from '../../core/cardSelector/BaseCardSelector';
import { PlayType } from '../../core/Constants';
import { PlayCardResourceCost } from '../../costs/PlayCardResourceCost';
import { DefeatCardSystem } from '../../gameSystems/DefeatCardSystem';
import { DefeatSourceType } from '../../IDamageOrDefeatSource';

export class ExploitPlayCardResourceCost extends PlayCardResourceCost {
    private readonly cardSelector: BaseCardSelector;
    private readonly defeatSystem: DefeatCardSystem;
    private readonly exploitAmount: number;

    private exploitedUnits: UnitCard[] = [];
    private exploitCostResolved = false;

    public constructor(exploitAmount: number, playType: PlayType) {
        super(playType);

        this.defeatSystem = new DefeatCardSystem({ defeatSource: DefeatSourceType.Ability });

        this.cardSelector = new BaseCardSelector({
            cardCondition: (card) => card.isUnit(),
            cardType: UnitCard,
            gameAction: this.defeatSystem
        });
    }

    public override usesExploit(): this is ExploitPlayCardResourceCost {
        return true;
    }

    /**
     * If exploit has been resolved and units defeated, returns the discount amount based on number of units chosen.
     * Otherwise, returns the maximum possible discount.
     */
    private getDiscountAmount(card: Card): number {
        if (card !== this.source) {
            return 0;
        }

        return this.exploitCostResolved ? this.exploitAmount * 2 : this.exploitedUnits.length * 2;
    }

    private getMinimumTargets() {
        return 1;
    }

    public canPay() {
        return true;
    }
}