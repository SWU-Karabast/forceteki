import type { AbilityContext } from '../../core/ability/AbilityContext';
import { CardTargetResolver } from '../../core/ability/abilityTargets/CardTargetResolver';
import type { Card } from '../../core/card/Card';
import type { CardWithCost } from '../../core/card/CardTypes';
import type { Aspect, PlayType } from '../../core/Constants';
import { EventName, RelativePlayer, TargetMode, WildcardCardType } from '../../core/Constants';
import type { Result } from '../../core/cost/ICost';
import { GameEvent } from '../../core/event/GameEvent';
import * as Contract from '../../core/utils/Contract';
import { PlayCardResourceCost } from '../../costs/PlayCardResourceCost';
import type { IDefeatCardProperties } from '../../gameSystems/DefeatCardSystem';
import { DefeatCardSystem } from '../../gameSystems/DefeatCardSystem';
import { DefeatSourceType } from '../../IDamageOrDefeatSource';

export class ExploitPlayCardResourceCost extends PlayCardResourceCost {
    private readonly defeatSystem: DefeatCardSystem;
    private readonly exploitKeywordAmount: number;
    private readonly targetResolver: CardTargetResolver;

    private minimumExploitCount?: number = null;

    public constructor(card: CardWithCost, exploitKeywordAmount: number, playType: PlayType, resources: number = null, aspects: Aspect[] = null) {
        super(card, playType, resources, aspects);

        this.exploitKeywordAmount = exploitKeywordAmount;

        const defeatProps: IDefeatCardProperties = { defeatSource: DefeatSourceType.Ability };
        this.defeatSystem = new DefeatCardSystem(defeatProps);

        this.targetResolver = new CardTargetResolver(
            'exploit', {
                mode: TargetMode.BetweenVariable,
                minNumCardsFunc: () => this.minimumExploitCount ?? 1,
                maxNumCardsFunc: (context) => this.getMaxExploitCount(context),
                cardTypeFilter: WildcardCardType.Unit,
                immediateEffect: this.defeatSystem,
                controller: RelativePlayer.Self,
                appendToDefaultTitle: 'to exploit',
            }
        );
    }

    public override usesExploit(): this is ExploitPlayCardResourceCost {
        return true;
    }

    public override canPay(context: AbilityContext<Card>) {
        return this.targetResolver.hasLegalTarget(context) && super.canPay(context);
    }

    // TODO: we need to have a cancel option at the exploit target stage
    public override resolve(context: AbilityContext<Card>, result: Result) {
        const adjustedCost = super.getAdjustedCost(context);

        this.minimumExploitCount = Math.max(1, Math.ceil((adjustedCost - context.player.readyResourceCount) / 2));

        if (this.getMaxExploitCount(context) < this.minimumExploitCount) {
            result.cancelled = true;
            return;
        }

        this.targetResolver.resolve(context, result);
    }

    public override payEvents(context) {
        Contract.assertNotNullLike(context.targets.exploit);
        Contract.assertIsNullLike(context.costs.exploitedUnitsInformation);

        const payEvents = [];
        context.costs.exploitedUnitsInformation = [];

        // create the events for defeating the exploited units
        for (const exploitUnit of context.targets.exploit) {
            payEvents.push(this.defeatSystem.generateRetargetedEvent(exploitUnit, context));
        }

        // create an event for the Exploit operation itself, which will cache the "last known information"
        // of the exploited units in case it needs to be referred to by abilities
        const exploitEvent = new GameEvent(
            EventName.onExploitUnits,
            context,
            { units: context.targets.exploit },
            (_event) => {
                for (const exploitEvent of payEvents) {
                    Contract.assertTrue(exploitEvent.isResolvedOrReplacementResolved);

                    context.costs.exploitedUnitsInformation.push(exploitEvent.lastKnownInformation);
                }
            }
        );

        // the Exploit event will emit the defeat events as contingent events and resolve them in earlier order
        exploitEvent.setContingentEventsGenerator((event) => {
            for (const payEvent of payEvents) {
                payEvent.order = event.order - 1;
            }
            return [...payEvents];
        });

        const remainingCost = Math.max(0, super.getAdjustedCost(context) - (context.targets.exploit.length * 2));

        return [exploitEvent, this.getExhaustResourceEvent(context, remainingCost)];
    }

    protected override getAdjustedCost(context: AbilityContext<Card>) {
        return Math.max(0, super.getAdjustedCost(context) - (this.getMaxExploitCount(context) * 2));
    }

    private getMaxExploitCount(context: AbilityContext) {
        return Math.min(this.exploitKeywordAmount, this.targetResolver.getAllLegalTargets(context).length);
    }
}
