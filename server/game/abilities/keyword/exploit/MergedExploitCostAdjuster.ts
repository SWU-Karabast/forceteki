import { ExploitCostAdjuster } from './ExploitCostAdjuster';
import * as Contract from '../../../core/utils/Contract';
import type { ICardWithCostProperty } from '../../../core/card/propertyMixins/Cost';
import type { AbilityContext } from '../../../core/ability/AbilityContext';
import { CostAdjustType } from '../../../core/cost/CostAdjuster';

import { registerState } from '../../../core/GameObjectUtils';

/**
 * Helper class used to resolve multiple exploit cost adjusters at once
 */
@registerState()
export class MergedExploitCostAdjuster extends ExploitCostAdjuster {
    private readonly mergedAdjusters: ExploitCostAdjuster[] = [];

    public constructor(adjusters: ExploitCostAdjuster[], card: ICardWithCostProperty, context: AbilityContext) {
        Contract.assertNotNullLike(adjusters);
        Contract.assertTrue(adjusters.length > 1, `Attempting to merge Exploit adjusters array of length ${adjusters.length}`);

        const totalExploitAmount = adjusters.reduce((total, adjuster) => total + adjuster.exploitKeywordAmount, 0);

        super(
            context.game,
            card,
            { costAdjustType: CostAdjustType.Exploit, exploitKeywordAmount: totalExploitAmount }
        );

        this.addMergedAdjusters(adjusters);
    }

    public override markUsed() {
        super.markUsed();
        for (const adjuster of this.mergedAdjusters) {
            adjuster.markUsed();
        }
    }

    public override cancel() {
        super.cancel();
        for (const adjuster of this.mergedAdjusters) {
            adjuster.cancel();
        }
    }

    private addMergedAdjusters(adjusters: ExploitCostAdjuster[]) {
        this.mergedAdjusters.push(...adjusters);
    }
}
