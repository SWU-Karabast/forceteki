import { ExploitCostAdjuster } from './ExploitCostAdjuster';
import * as Contract from '../../../core/utils/Contract';
import type { ICardWithCostProperty } from '../../../core/card/propertyMixins/Cost';
import type { AbilityContext } from '../../../core/ability/AbilityContext';

/**
 * Helper class used to resolve multiple exploit cost adjusters at once
 */
export class MergedExploitCostAdjuster extends ExploitCostAdjuster {
    private readonly mergedAdjusters: ExploitCostAdjuster[] = [];

    public override get numExploitedCards() {
        if (this.mergedAdjusters.length === 0) {
            return null;
        }

        return this.sumExploitedCards();
    }

    protected override set numExploitedCards(value) {
        Contract.assertTrue(this.mergedAdjusters.length > 0);

        if (this.mergedAdjusters.length > 0) {
            this.distributeExploitedCardsAmount(value);
        }
    }

    public constructor(adjusters: ExploitCostAdjuster[], card: ICardWithCostProperty, context: AbilityContext) {
        Contract.assertNotNullLike(adjusters);
        Contract.assertTrue(adjusters.length > 1, `Attempting to merge Exploit adjusters array of length ${adjusters.length}`);

        const totalExploitAmount = adjusters.reduce((total, adjuster) => total + adjuster.exploitKeywordAmount, 0);

        super(
            context.game,
            card,
            { exploitKeywordAmount: totalExploitAmount }
        );

        this.addMergedAdjusters(adjusters);
    }

    public override resetForCancel(): void {
        super.resetForCancel();
        for (const adjuster of this.mergedAdjusters) {
            adjuster.resetForCancel();
        }
    }

    private distributeExploitedCardsAmount(numExploitedCards: number) {
        let remainingExploitedCards = numExploitedCards;
        for (const adjuster of this.mergedAdjusters) {
            const maxExploitCount = adjuster.exploitKeywordAmount;
            const exploitedAmountToAssign = Math.min(maxExploitCount, remainingExploitedCards);
            remainingExploitedCards -= exploitedAmountToAssign;

            adjuster.markResolvedByMerge(exploitedAmountToAssign);
        }
    }

    public override markUsed() {
        super.markUsed();
        for (const adjuster of this.mergedAdjusters) {
            adjuster.markUsed();
        }
    }

    public override unregisterEvents() {
        super.unregisterEvents();
        for (const adjuster of this.mergedAdjusters) {
            adjuster.unregisterEvents();
        }
    }

    private addMergedAdjusters(adjusters: ExploitCostAdjuster[]) {
        this.mergedAdjusters.push(...adjusters);
    }

    private sumExploitedCards() {
        let shouldAllBeNull = null;
        let total = 0;
        for (const adjuster of this.mergedAdjusters) {
            if (shouldAllBeNull == null) {
                shouldAllBeNull = adjuster.numExploitedCards == null;
            } else {
                Contract.assertTrue(
                    adjuster.numExploitedCards == null === shouldAllBeNull,
                    'Merged exploit adjuster found inconsistent resolved state among sub-adjusters'
                );
            }

            total += adjuster.numExploitedCards ?? 0;
        }

        return shouldAllBeNull ? null : total;
    }
}
