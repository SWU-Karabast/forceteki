import type { AbilityContext } from '../../../core/ability/AbilityContext';
import { PerPlayerPerGameAbilityLimit } from '../../../core/ability/AbilityLimit';
import type { Card } from '../../../core/card/Card';
import type { ICardWithCostProperty } from '../../../core/card/propertyMixins/Cost';
import type { IUnitCard } from '../../../core/card/propertyMixins/UnitProperties';
import { EventName } from '../../../core/Constants';
import type { IExploitCostAdjusterProperties } from '../../../core/cost/CostAdjuster';
import { CostAdjustType } from '../../../core/cost/CostAdjuster';
import type { IAbilityCostAdjustmentProperties } from '../../../core/cost/CostInterfaces';
import { CostAdjustStage } from '../../../core/cost/CostInterfaces';
import { TargetedCostAdjuster } from '../../../core/cost/TargetedCostAdjuster';
import type Game from '../../../core/Game';
import type { GameSystem } from '../../../core/gameSystem/GameSystem';
import type { IDefeatCardProperties } from '../../../gameSystems/DefeatCardSystem';
import { DefeatCardSystem } from '../../../gameSystems/DefeatCardSystem';
import { DefeatSourceType } from '../../../IDamageOrDefeatSource';

import { registerState } from '../../../core/GameObjectUtils';

@registerState()
export class ExploitCostAdjuster extends TargetedCostAdjuster {
    public static readonly contextPropertyName = 'exploit';

    public readonly exploitKeywordAmount: number;

    public constructor(
        game: Game,
        source: ICardWithCostProperty,
        properties: IExploitCostAdjusterProperties
    ) {
        super(game, source, CostAdjustStage.Exploit_1,
            {
                limit: new PerPlayerPerGameAbilityLimit(game, 1),
                ...properties,
                costAdjustType: CostAdjustType.Exploit,
                adjustAmountPerTarget: 2,
                costPropertyName: ExploitCostAdjuster.contextPropertyName,
                useAdjusterButtonText: 'Trigger Exploit',
                doNotUseAdjusterButtonText: 'Play without Exploit',
                eventName: EventName.OnExploitUnits,
                promptSuffix: 'to exploit',
                maxTargetCount: properties.exploitKeywordAmount
            }
        );

        this.exploitKeywordAmount = properties.exploitKeywordAmount;
    }

    /** The only cases that we need to worry about opportunity cost for are Starhawk and Vuutun Palaa */
    protected override doesAdjustmentUseOpportunityCost(adjustmentProps: IAbilityCostAdjustmentProperties) {
        const otherAdjustStages = adjustmentProps.matchingAdjusters;

        return otherAdjustStages.get(CostAdjustStage.ExhaustUnits_3)?.length > 0 ||
          otherAdjustStages.get(CostAdjustStage.PayStage_2)?.length > 0;
    }

    protected override buildEffectSystem(): GameSystem<AbilityContext<IUnitCard>> {
        const defeatProps: IDefeatCardProperties = { defeatSource: DefeatSourceType.Ability };
        return new DefeatCardSystem(defeatProps);
    }

    public override isExploit(): this is ExploitCostAdjuster {
        return true;
    }

    /**
     * If there's an opportunity cost, this will show a prompt that dynamically updates with the relevant values
     * so that players can understand why things are changing as they click on targets
     */
    protected override buildActivePromptTitleHandler(
        adjustmentProps: IAbilityCostAdjustmentProperties
    ): ((context: AbilityContext, selectedCards: Card[]) => string) | null {
        if (!this.doesAdjustmentUseOpportunityCost(adjustmentProps)) {
            return null;
        }

        const handler = (context: AbilityContext, selectedCards: Card[]) => {
            const exploitAdjustment = this.adjustAmountPerTarget * selectedCards.length;
            const otherDiscount = context.costs[this.costPropertyName].otherDiscountsAmount ?? 0;

            const totalCost = (adjustmentProps.getTotalResourceCost() - exploitAdjustment) - otherDiscount;

            return `Cost: ${adjustmentProps.getTotalResourceCost()} Exploit: ${-exploitAdjustment} Discounts: ${-otherDiscount} Total: ${totalCost}`;
        };

        return handler;
    }
}
