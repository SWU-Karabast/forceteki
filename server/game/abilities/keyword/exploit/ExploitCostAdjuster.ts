import type { AbilityContext } from '../../../core/ability/AbilityContext';
import { PerPlayerPerGameAbilityLimit } from '../../../core/ability/AbilityLimit';
import { CardTargetResolver } from '../../../core/ability/abilityTargets/CardTargetResolver';
import type { Card } from '../../../core/card/Card';
import type { ICardWithCostProperty } from '../../../core/card/propertyMixins/Cost';
import { EventName, RelativePlayer, TargetMode, WildcardCardType } from '../../../core/Constants';
import type { IExploitCostAdjusterProperties } from '../../../core/cost/CostAdjuster';
import { CostAdjuster, CostAdjustType } from '../../../core/cost/CostAdjuster';
import { CostAdjustStage, type ICostAdjustEvaluationResult, type ICostAdjustTriggerResult } from '../../../core/cost/CostInterfaces';
import type { ICostResult } from '../../../core/cost/ICost';
import { GameEvent } from '../../../core/event/GameEvent';
import type Game from '../../../core/Game';
import type { Player } from '../../../core/Player';
import * as Contract from '../../../core/utils/Contract';
import * as Helpers from '../../../core/utils/Helpers';
import type { IDefeatCardProperties } from '../../../gameSystems/DefeatCardSystem';
import { DefeatCardSystem } from '../../../gameSystems/DefeatCardSystem';
import { DefeatSourceType } from '../../../IDamageOrDefeatSource';

export class ExploitCostAdjuster extends CostAdjuster {
    public readonly exploitKeywordAmount: number;

    private readonly defeatSystem: DefeatCardSystem;
    private readonly targetResolver: CardTargetResolver;

    public constructor(
        game: Game,
        source: ICardWithCostProperty,
        properties: Omit<IExploitCostAdjusterProperties, 'limit'>
    ) {
        super(game, source,
            {
                ...properties,
                costAdjustType: CostAdjustType.Exploit,
                limit: new PerPlayerPerGameAbilityLimit(game, 1)
            }
        );

        this.exploitKeywordAmount = properties.exploitKeywordAmount;

        const defeatProps: IDefeatCardProperties = { defeatSource: DefeatSourceType.Ability };
        this.defeatSystem = new DefeatCardSystem(defeatProps);

        this.targetResolver = new CardTargetResolver(
            'exploit', {
                mode: TargetMode.BetweenVariable,
                minNumCardsFunc: (context) => context.costs.minimumExploitCount ?? 1,
                maxNumCardsFunc: (context) => this.getMaxExploitCount(context),
                cardTypeFilter: WildcardCardType.Unit,
                immediateEffect: this.defeatSystem,
                controller: RelativePlayer.Self,
                appendToDefaultTitle: 'to exploit',
            }
        );
    }

    protected override getCostStage(costAdjustType: CostAdjustType): CostAdjustStage {
        Contract.assertTrue(costAdjustType === CostAdjustType.Exploit, `ExploitCostAdjuster must have costAdjustType of '${CostAdjustType.Exploit}', instead got '${costAdjustType}'`);
        return CostAdjustStage.Exploit_1;
    }

    public override isExploit(): this is ExploitCostAdjuster {
        return true;
    }

    protected override canAdjust(card: Card, context: AbilityContext<ICardWithCostProperty>, evaluationResult: ICostAdjustEvaluationResult) {
        // check available legal targets
        if (!this.targetResolver.hasLegalTarget(context)) {
            return false;
        }

        return super.canAdjust(card, context, evaluationResult);
    }

    public override getAmount(card: Card, player: Player, context: AbilityContext, currentAmount: number = null): number {
        return this.getMaxExploitCount(context) * 2;
    }

    public override queueGenerateEventGameSteps(
        events: any[],
        context: AbilityContext<ICardWithCostProperty>,
        costAdjustTriggerResult: ICostAdjustTriggerResult,
        abilityCostResult?: ICostResult
    ) {
        Contract.assertIsNullLike(context.costs.minimumExploitCount);

        // TODO: move this up to triggered adjuster base class so it always happens
        this.checkAddAdjusterToTriggerList(context.source, costAdjustTriggerResult);

        // calculate available downstream adjustments so we can determine how much we are required to Exploit
        const preAdjustedCost = this.getMinimumPossibleRemainingCost(context, costAdjustTriggerResult);

        const maxExploitableUnitsCount = this.getMaxExploitCount(context);
        const minimumExploitRequiredToPay = Math.max(0, Math.ceil((preAdjustedCost - context.player.readyResourceCount) / 2));
        context.costs.minimumExploitCount = Math.max(1, minimumExploitRequiredToPay);

        // payment shouldn't have been triggered if there aren't enough exploitable units available to pay the minimum
        Contract.assertTrue(maxExploitableUnitsCount >= minimumExploitRequiredToPay);

        // if no exploitable units, shortcut past exploit prompt
        if (maxExploitableUnitsCount === 0) {
            return;
        }

        const canPlayWithoutExploit = minimumExploitRequiredToPay === 0;

        // TODO: once we have a real cancel flow, enable cancel here in the case of an Exploit card being played via another card's ability
        // if Exploit is the only option that would be shown, just go directly to target selection
        if (!abilityCostResult.canCancel && !canPlayWithoutExploit) {
            this.resolveExploit(events, context, costAdjustTriggerResult, abilityCostResult);
            return;
        }

        const choices = ['Trigger Exploit'];
        const handlers = [
            () => this.resolveExploit(events, context, costAdjustTriggerResult, abilityCostResult)
        ];

        if (abilityCostResult.canCancel) {
            choices.push('Cancel');
            handlers.push(() => {
                abilityCostResult.cancelled = true;
            });
        }

        // add normal play option if available
        if (canPlayWithoutExploit) {
            choices.unshift('Play without Exploit');
            handlers.unshift(() => undefined);
        }

        context.game.promptWithHandlerMenu(context.player, {
            activePromptTitle: `Choose pay mode for ${context.source.title}`,
            choices,
            handlers
        });
    }

    protected override applyMaxAdjustmentAmount(_card: Card, context: AbilityContext, result: ICostAdjustTriggerResult) {
        const adjustAmount = this.getMaxExploitCount(context) * 2;
        result.remainingCost -= adjustAmount;
    }

    private resolveExploit(
        events: any[],
        context: AbilityContext,
        costAdjustTriggerResult: ICostAdjustTriggerResult,
        abilityCostResult: ICostResult
    ) {
        // step 1: ask player to choose defeat targets
        this.targetResolver.resolve(context, abilityCostResult);

        // step 2: generate the Exploit event (which in turn emits the defeat events)
        context.game.queueSimpleStep(() => {
            if (!abilityCostResult.cancelled) {
                costAdjustTriggerResult.remainingCost -= this.getExploitedUnitsCount(context) * 2;
                events.push(this.buildExploitEvent(context));
            }
        }, `generate exploit event for ${context.source.internalName}`);
    }

    private buildExploitEvent(context) {
        Contract.assertNotNullLike(context.targets.exploit);
        Contract.assertIsNullLike(context.costs.exploitedUnitsInformation);

        const payEvents = [];
        context.costs.exploitedUnitsInformation = [];

        const exploitTargets = Helpers.asArray(context.targets.exploit);

        // create the events for defeating the exploited units
        for (const exploitUnit of exploitTargets) {
            payEvents.push(this.defeatSystem.generateRetargetedEvent(exploitUnit, context));
        }

        // create an event for the Exploit operation itself, which will cache the "last known information"
        // of the exploited units in case it needs to be referred to by abilities
        const exploitEvent = new GameEvent(
            EventName.OnExploitUnits,
            context,
            { units: exploitTargets },
            (_event) => {
                for (const exploitEvent of payEvents) {
                    Contract.assertTrue(exploitEvent.isResolvedOrReplacementResolved);

                    context.costs.exploitedUnitsInformation.push(exploitEvent.lastKnownInformation);
                }
            }
        );

        // the Exploit event will emit the defeat events as contingent events and resolve them in earlier order
        exploitEvent.setContingentEventsGenerator((event) => {
            for (const payEvent of payEvents) {
                payEvent.order = event.order - 1;
            }
            return [...payEvents];
        });

        return exploitEvent;
    }

    private getMaxExploitCount(context: AbilityContext) {
        return Math.min(this.exploitKeywordAmount, this.targetResolver.getAllLegalTargets(context).length);
    }

    private getExploitedUnitsCount(context: AbilityContext): number {
        return Helpers.asArray(context.targets.exploit)?.length || 0;
    }
}
