import type { AbilityContext } from '../../../core/ability/AbilityContext';
import { PerPlayerPerGameAbilityLimit } from '../../../core/ability/AbilityLimit';
import { CardTargetResolver } from '../../../core/ability/abilityTargets/CardTargetResolver';
import type { Card } from '../../../core/card/Card';
import type { ICardWithCostProperty } from '../../../core/card/propertyMixins/Cost';
import { EventName, RelativePlayer, TargetMode, WildcardCardType } from '../../../core/Constants';
import type { ICanAdjustProperties, ICostAdjusterPropertiesBase } from '../../../core/cost/CostAdjuster';
import { CostAdjustType } from '../../../core/cost/CostAdjuster';
import type { ICostResult } from '../../../core/cost/ICost';
import { GameEvent } from '../../../core/event/GameEvent';
import type Game from '../../../core/Game';
import * as Contract from '../../../core/utils/Contract';
import * as Helpers from '../../../core/utils/Helpers';
import type { PlayCardResourceCost } from '../../../costs/PlayCardResourceCost';
import type { IDefeatCardProperties } from '../../../gameSystems/DefeatCardSystem';
import { DefeatCardSystem } from '../../../gameSystems/DefeatCardSystem';
import { DefeatSourceType } from '../../../IDamageOrDefeatSource';
import { ExploitCostAdjusterBase } from './ExploitCostAdjusterBase';

export interface IExploitCostAdjusterProperties extends Omit<ICostAdjusterPropertiesBase, 'costAdjustType'> {
    exploitKeywordAmount: number;
}

export class ExploitCostAdjuster extends ExploitCostAdjusterBase {
    public readonly exploitKeywordAmount: number;

    private readonly defeatSystem: DefeatCardSystem;
    private readonly targetResolver: CardTargetResolver;

    private minimumExploitCount?: number = null;

    public constructor(
        game: Game,
        source: ICardWithCostProperty,
        properties: Omit<IExploitCostAdjusterProperties, 'limit'>
    ) {
        super(game, source,
            {
                ...properties,
                costAdjustType: CostAdjustType.Decrease,

                // if we haven't yet resolved the exploit targets, just return the maximum possible discount amount
                amount: (_card, _player, context) =>
                    (this.numExploitedCards != null ? this.numExploitedCards * 2 : this.getMaxExploitCount(context) * 2),
                limit: new PerPlayerPerGameAbilityLimit(game, 1)
            }
        );

        this.exploitKeywordAmount = properties.exploitKeywordAmount;

        const defeatProps: IDefeatCardProperties = { defeatSource: DefeatSourceType.Ability };
        this.defeatSystem = new DefeatCardSystem(defeatProps);

        this.targetResolver = new CardTargetResolver(
            'exploit', {
                mode: TargetMode.BetweenVariable,
                minNumCardsFunc: () => this.minimumExploitCount ?? 1,
                maxNumCardsFunc: (context) => this.getMaxExploitCount(context),
                cardTypeFilter: WildcardCardType.Unit,
                immediateEffect: this.defeatSystem,
                controller: RelativePlayer.Self,
                appendToDefaultTitle: 'to exploit',
            }
        );
    }

    public override isExploit(): this is ExploitCostAdjuster {
        return true;
    }

    public markResolvedByMerge(numExploitedCards: number) {
        this.numExploitedCards = numExploitedCards;
    }

    public override canAdjust(card: Card, context: AbilityContext<ICardWithCostProperty>, adjustParams: ICanAdjustProperties) {
        // if we haven't already triggered the Exploit selection, check available legal targets
        if (this.numExploitedCards == null && !this.targetResolver.hasLegalTarget(context)) {
            return false;
        }

        return super.canAdjust(card, context, adjustParams);
    }

    public override queueGenerateEventGameSteps(
        events: any[],
        context: AbilityContext<ICardWithCostProperty>,
        resourceCost: PlayCardResourceCost,
        result?: ICostResult
    ) {
        Contract.assertIsNullLike(this.minimumExploitCount);
        Contract.assertIsNullLike(this.numExploitedCards);

        // briefly remove ourself from the cost adjustment calculation so we can determine how much we are required to Exploit
        const preAdjustedCost = resourceCost.getAdjustedCost(context, true);

        const maxExploitableUnitsCount = this.getMaxExploitCount(context);
        const minimumExploitRequiredToPay = Math.max(0, Math.ceil((preAdjustedCost - context.player.readyResourceCount) / 2));
        this.minimumExploitCount = Math.max(1, minimumExploitRequiredToPay);

        // payment shouldn't have been triggered if there aren't enough exploitable units available to pay the minimum
        Contract.assertTrue(maxExploitableUnitsCount >= minimumExploitRequiredToPay);

        // if no exploitable units, shortcut past exploit prompt
        if (maxExploitableUnitsCount === 0) {
            this.numExploitedCards = 0;
            return;
        }

        const canPlayWithoutExploit = minimumExploitRequiredToPay === 0;

        // TODO: once we have a real cancel flow, enable cancel here in the case of an Exploit card being played via another card's ability
        // if Exploit is the only option that would be shown, just go directly to target selection
        if (!result.canCancel && !canPlayWithoutExploit) {
            this.resolveExploit(events, context, result);
            return;
        }

        const choices = ['Trigger Exploit'];
        const handlers = [
            () => this.resolveExploit(events, context, result)
        ];

        if (result.canCancel) {
            choices.push('Cancel');
            handlers.push(() => {
                result.cancelled = true;
                this.resetForCancel();
            });
        }

        // add normal play option if available
        if (canPlayWithoutExploit) {
            choices.unshift('Play without Exploit');
            handlers.unshift(() => {
                this.numExploitedCards = 0;
            });
        }

        context.game.promptWithHandlerMenu(context.player, {
            activePromptTitle: `Choose pay mode for ${context.source.title}`,
            choices,
            handlers
        });
    }

    public resetForCancel() {
        // reset the cost adjuster so it can be used again after a cancel
        this.minimumExploitCount = null;
        this.numExploitedCards = null;
    }

    private resolveExploit(events: any[], context: AbilityContext, result: ICostResult) {
        // step 1: ask player to choose defeat targets
        this.targetResolver.resolve(context, result);

        // step 2: generate the Exploit event (which in turn emits the defeat events)
        context.game.queueSimpleStep(() => {
            if (!result.cancelled) {
                this.numExploitedCards = Helpers.asArray(context.targets.exploit).length;
                events.push(this.buildExploitEvent(context));
            }
        }, `generate exploit event for ${context.source.internalName}`);
    }

    private buildExploitEvent(context) {
        Contract.assertNotNullLike(context.targets.exploit);
        Contract.assertIsNullLike(context.costs.exploitedUnitsInformation);

        const payEvents = [];
        context.costs.exploitedUnitsInformation = [];

        const exploitTargets = Helpers.asArray(context.targets.exploit);

        // create the events for defeating the exploited units
        for (const exploitUnit of exploitTargets) {
            payEvents.push(this.defeatSystem.generateRetargetedEvent(exploitUnit, context));
        }

        // create an event for the Exploit operation itself, which will cache the "last known information"
        // of the exploited units in case it needs to be referred to by abilities
        const exploitEvent = new GameEvent(
            EventName.OnExploitUnits,
            context,
            { units: exploitTargets },
            (_event) => {
                for (const exploitEvent of payEvents) {
                    Contract.assertTrue(exploitEvent.isResolvedOrReplacementResolved);

                    context.costs.exploitedUnitsInformation.push(exploitEvent.lastKnownInformation);
                }
            }
        );

        // the Exploit event will emit the defeat events as contingent events and resolve them in earlier order
        exploitEvent.setContingentEventsGenerator((event) => {
            for (const payEvent of payEvents) {
                payEvent.order = event.order - 1;
            }
            return [...payEvents];
        });

        return exploitEvent;
    }

    private getMaxExploitCount(context: AbilityContext) {
        return Math.min(this.exploitKeywordAmount, this.targetResolver.getAllLegalTargets(context).length);
    }
}
