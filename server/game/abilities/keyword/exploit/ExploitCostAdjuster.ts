import type { AbilityContext } from '../../../core/ability/AbilityContext';
import { PerPlayerPerGameAbilityLimit } from '../../../core/ability/AbilityLimit';
import type { ICardWithCostProperty } from '../../../core/card/propertyMixins/Cost';
import type { IUnitCard } from '../../../core/card/propertyMixins/UnitProperties';
import { EventName } from '../../../core/Constants';
import type { IExploitCostAdjusterProperties } from '../../../core/cost/CostAdjuster';
import { CostAdjustType } from '../../../core/cost/CostAdjuster';
import { CostAdjustStage } from '../../../core/cost/CostInterfaces';
import { TargetedCostAdjuster } from '../../../core/cost/TargetedCostAdjuster';
import type Game from '../../../core/Game';
import type { GameSystem } from '../../../core/gameSystem/GameSystem';
import * as Contract from '../../../core/utils/Contract';
import type { IDefeatCardProperties } from '../../../gameSystems/DefeatCardSystem';
import { DefeatCardSystem } from '../../../gameSystems/DefeatCardSystem';
import { DefeatSourceType } from '../../../IDamageOrDefeatSource';

export class ExploitCostAdjuster extends TargetedCostAdjuster {
    public static readonly contextPropertyName = 'exploit';

    public readonly exploitKeywordAmount: number;

    public constructor(
        game: Game,
        source: ICardWithCostProperty,
        properties: IExploitCostAdjusterProperties
    ) {
        super(game, source,
            {
                limit: new PerPlayerPerGameAbilityLimit(game, 1),
                ...properties,
                costAdjustType: CostAdjustType.Exploit,
                adjustAmountPerTarget: 2,
                costPropertyName: ExploitCostAdjuster.contextPropertyName,
                useAdjusterButtonText: 'Trigger Exploit',
                doNotUseAdjusterButtonText: 'Play without Exploit',
                eventName: EventName.OnExploitUnits,
                promptSuffix: 'to exploit',
                maxTargetCount: properties.exploitKeywordAmount
            }
        );

        this.exploitKeywordAmount = properties.exploitKeywordAmount;
    }

    protected override buildEffectSystem(): GameSystem<AbilityContext<IUnitCard>> {
        const defeatProps: IDefeatCardProperties = { defeatSource: DefeatSourceType.Ability };
        return new DefeatCardSystem(defeatProps);
    }

    protected override getCostStage(costAdjustType: CostAdjustType): CostAdjustStage {
        Contract.assertTrue(costAdjustType === CostAdjustType.Exploit, `ExploitCostAdjuster must have costAdjustType of '${CostAdjustType.Exploit}', instead got '${costAdjustType}'`);
        return CostAdjustStage.Exploit_1;
    }

    public override isExploit(): this is ExploitCostAdjuster {
        return true;
    }
}
